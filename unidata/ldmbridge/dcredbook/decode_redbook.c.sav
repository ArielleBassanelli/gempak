#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <time.h>

#include <dccmn.h>

#include <uscore.h>

#ifdef UNDERSCORE
#define aw_read	aw_read_
#define gqmode	gqmode_
#endif

decode_redbook(device,rawfile,iret)
char *device,*rawfile;
int *iret;
{
int i, ier;
int idrpfl;
int color, itype, iwidth,  arg1=0, arg2=0;
int in_file, out_file;
mode_t omode=S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH;
int START=0;
float lat[4],lon[4],fproj[3];
struct tm redtime;
time_t prodtime;

char outfilenm[256],outtmpl[256],outtemp[276],*pos,*cpos,*tempnam,buf[512],tstr[128];
char DEV[10],*optparms=NULL,outdev[512];
char pnam[7],ptype[10];
char PIL[10],TITLE[256],prod1[80],prod2[80];
char **aryptr;
static char proj[50];
char garea[30];
char gemtime[20];
char errstr[81];
static char imgfls[] = " ";
/*static char mapfil[] = "hipowo.cia ";*/
static char mapfil[] = "mepowo.gsf ";
static char map[] = "2/1/1 ";
static char dbug[] = " ";
FILE *fp;

*iret = 0;

aryptr = (char **) malloc(sizeof(char *) * 1);
aryptr[0] = (char *)malloc(80);

tempnam = (char *)malloc(16);
tempnam[0] = '\0';
sprintf(tempnam,".redbook.XXXXXX\0");
mktemp(tempnam);

outfilenm[0] = '\0';
DEV[0] = '\0';


pos = (char *)strchr(device,'|');
if((pos != NULL)&&(pos[1] != '\0'))
   {
   strncat(DEV,device,pos-device);

   cpos = (char *)strchr(pos+1,'|');
   optparms = cpos;
   strncat(outfilenm,pos+1,cpos-pos-1);

   udebug("creating temporary redbook file %s\0",tempnam);
   /* create temp file in directory of output  (get path to ofil)*/
   pos = strrchr(outfilenm,'/');
   if(pos == NULL)
      strcpy(outtemp,tempnam);
   else
      {
      outtemp[0] = '\0';
      strncat(outtemp,outfilenm,pos-outfilenm);
      strncat(outtemp,"/",1);
      strcat(outtemp,tempnam);
      }
   }
else
   {
   outtemp[0] = '\0';
   sprintf(outtemp,"/tmp/%s\0",tempnam);
   strncat(DEV,device,9);
   }

free(tempnam);
/*printf("output device %s outtemp %s\n",device,outtemp);*/

in_file = STDIN_FILENO;
out_file = mkdirs_open(outtemp,O_WRONLY|O_CREAT|O_TRUNC,omode);
if(out_file < 0)
   {
   sprintf(errstr,"could not open %s\0",outtemp);
   dc_wclg(0,"DCREDBOOK",-1,errstr,&ier);
   *iret = -1;
   return;
   }

tstr[0] = '\0';
while((i = read(in_file,buf,512)) > 0) 
   {
   write(out_file,buf,i);
   if(START == 0)
      {
      START++;
      lat[0] = -9999; lon[0] = -9999; fproj[0] = -9999; pnam[0] = '\0';
      redbook_header(buf,tstr,lat,lon,fproj,pnam);
      /*printf("look tstr %s [%f %f proj %f %f %f]\n",tstr,lat[0],lon[0],
              fproj[0],fproj[1],fproj[2]);
      printf("check pnam %s\n",pnam);*/
      }
   }
close(out_file);

i=1;
gg_init(&i, &ier);

/* Add call to query mode to load this routine...since gemlib
** routine gp_azdr will try to access this routine later
*/
gqmode(&i,&ier);

if(lat[0] != -9999)
   {
   sprintf(garea,"%6.2f;%7.2f;%6.2f;%7.2f\0",lat[0],lon[0],lat[1],lon[1]);
   }
else
   sprintf(garea,"AFNA\0");

sprintf(ptype,"STR\0");
if(pnam[0] != '\0')
   {
   if(strcmp(pnam,"PNHE01") == 0)
      sprintf(ptype,"STR\0");
   else if(strcmp(pnam,"PNAM02") == 0)
      sprintf(ptype,"STR\0");
   else
      printf("unknown pnam %s\n",pnam);
   }

if(fproj[0] != -9999)
   sprintf(proj,"%s/%.2f;%.2f;%.2f/NM\0",ptype,fproj[0],fproj[1],fproj[2]);
else
   sprintf(proj,"STR/90;-105;0/NM\0");

PIL[0] = '\0'; TITLE[0] = '\0';
if(tstr[0] != '\0')
   {
   if((cpos = strstr(tstr,"NMCGPH")) != NULL)
      {
      strncat(PIL,cpos+6,3);
      fp = (FILE *)cfl_tbop("redbook.tbl","nafos",&ier);
      if(fp != NULL)
         {
         ier = 0;
         while(ier == 0)
            {
            cfl_trln(fp,255,buf,&ier);
            if(strncmp(buf,PIL,strlen(PIL)) == 0)
               {
               cpos = strchr(buf,' ');
               if(cpos == NULL)
                  strcat(TITLE,buf);
               else
                  {
                  strncat(TITLE,buf,cpos-buf);
                  while((cpos[0] != '\n') && isspace(cpos[0])) cpos++;
	          cst_clst(cpos,' ',garea,1,80,aryptr,&i,&ier);
                  if((i > 0)&&(strcmp(aryptr[0],"*") != 0)) sprintf(garea,"%s\0",aryptr[0]);
                  }
	       dc_wclg(0,"DCREDBOOK",1,TITLE,&ier);
               ier = -10;
               }
            }
         cfl_clos(fp,&ier);
         }
      } 
   else if(tstr[0] == '/') /* use 2nd & third field */
      {
      cst_nocc(tstr+1,'/',2,0,&i,&ier);
      prod1[0] = '\0';
      strncat(prod1,tstr+1,i);
      sprintf(TITLE,"UNKNOWN_%s\0",prod1);
      fp = (FILE *)cfl_tbop("afosgraph.tbl","nafos",&ier);
      if(fp != NULL)
         {
         ier = 0;
         while(ier == 0)
            {
            cfl_trln(fp,255,buf,&ier);
            if(strncmp(buf,prod1,strlen(prod1)) == 0)
               {
               TITLE[0] = '\0';
               cpos = strchr(buf,' ');
               cst_nocc(prod1,'/',1,0,&i,&ier);
	       strncat(TITLE,prod1,i);
               cst_nocc(buf,'-',1,0,&i,&ier);
               if(cpos == NULL)
                  {
                  strcat(TITLE,buf+i);
                  }
               else
                  {
                  strncat(TITLE,buf+i,cpos-buf-i);
                  while((cpos[0] != '\n') && isspace(cpos[0])) cpos++;
                  cst_clst(cpos,' ',garea,1,80,aryptr,&i,&ier);
                  if((i > 0)&&(strcmp(aryptr[0],"*") != 0)) sprintf(garea,"%s\0",aryptr[0]);
                  }
               ier = -10;
               }
            }
         cfl_clos(fp,&ier);
         }
      dc_wclg(0,"DCREDBOOK",2,TITLE,&ier);
      }
   else
      {
      sprintf(TITLE,"UNKNOWN\0");
      dc_wclg(0,"DCREDBOOK",3,TITLE,&ier);
      }
 
   cst_nocc(tstr,'/',3,0,&i,&ier);
   gemtime[0] = '\0';
   strncat(gemtime,tstr+i+3,6);
   strncat(gemtime,"/",1);
   strncat(gemtime,tstr+i+10,4);
   cfl_mnam(gemtime,outfilenm,outtmpl,&ier);
   strcpy(outfilenm,outtmpl);
   }

if(strlen(outfilenm) > 0)
   {
   outdev[0] = '\0';
   pos = strstr(outfilenm,"%P");
   if((TITLE[0] != 0)&&(pos != NULL))
      {
      cpos = malloc(strlen(TITLE)+strlen(outfilenm));
      cpos[0] = '\0';
      strncat(cpos,outfilenm,pos-outfilenm);
      strcat(cpos,TITLE);
      strcat(cpos,pos+2);
      sprintf(outdev,"%s|%s\0",DEV,cpos);
      free(cpos);
      }
   else
      sprintf(outdev,"%s|%s\0",DEV,outfilenm);
   if(optparms != NULL)
      strcat(outdev,optparms);
   /*printf("look here %s\n",outdev);*/
   gg_sdev(outdev, &ier, strlen(outdev));
   }
else
   gg_sdev(device, &ier, strlen(device));


gg_maps ( proj, garea, imgfls, &idrpfl, &ier, strlen(proj),strlen(garea),strlen(imgfls));

gstanm(&ier);

gsmfil(mapfil, &ier, strlen(mapfil));
gg_map(map, &ier, strlen(map));

if((strncmp(device,"ps",2) == 0)||
   (strncmp(device,"PS",2) == 0))
   color = 4;
else
   color = 5;

gscolr(&color, &ier);
itype = 1;
iwidth = 1;
gsline(&itype, &arg1, &iwidth, &arg2, &ier );
aw_read(outtemp, dbug, &ier, strlen(outtemp)+1, strlen(dbug));

geplot(&ier);
genanm(&ier);

i=0;
gendp(&i, &ier);


if(rawfile[0] == '\0')
   unlink(outtemp);
else
   {
   if((cpos = strstr(rawfile,"%P")) != NULL)
      {
      tempnam = (char *)malloc(strlen(rawfile)+strlen(TITLE)+1);
      tempnam[0] = '\0';
      strncat(tempnam,rawfile,(cpos-rawfile));
      strcat(tempnam,TITLE);
      strcat(tempnam,cpos+2);
      ier = rename(outtemp,tempnam);
      free(tempnam);
      }
   else
      ier = rename(outtemp,rawfile);

   if(ier != 0)
      {
      sprintf(errstr,"Error storing redbook file %s\0",rawfile);
      dc_wclg(0,"DCREDBOOK",-10,errstr,&ier);
      *iret = -10;
      }
   }

nbull++;
}
